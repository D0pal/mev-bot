import { EventEmitter } from 'stream'

import { BlockCollector } from '@/core/collectors/block'
import { OpenseaListingCollector } from '@/core/collectors/opensea.listing'
import { Log } from '@/core/executors/log'
import { Strategy } from '@/core/strategy'

type Collectors = BlockCollector | OpenseaListingCollector
type Actions = Log

export class Engine {
	constructor(
		public readonly stream: EventEmitter = new EventEmitter(),
		public collectors: Array<Collectors> = [],
		public executors: Array<Actions> = [],
		public strategies: Array<Strategy<Collectors, Actions>> = []
	) {}

	run = async () => {
		// ! Catch actions that are generated by collected events.
		// ! This is run first so that we always have Executors
		//   listening for actions when the collectors start.
		const executorsPromise = this.executors.map(async executor =>
			this.stream.on('Execution', async action => {
				await executor.execute(action)
			})
		)

		const strategiesPromises = this.strategies.map(async strategy => {
			// ! Initialize the backfilled state.
			if (strategy.syncState) await strategy.syncState()

			// ! Catch and process events as they arrive from the collectors.
			// * Will emit:
			//   | 'Execution', ['Log', { ... }]
			//   | 'Execution', ['SubmitTransaction', { ... }]
			this.stream.on('Collection', async event => {
				// * A strategy will always consume the collection however
				//   that does not mean it will always be used. If there
				//   is an action that needs to be taken, then we plan
				//   on passing that to the configured Executors and if there
				//   is no action to take we will go back to waiting for
				//   future messages to arrive.
				const execution = await strategy.processCollection(event)

				// * If the strategy doesn't emit an action then
				//   we don't need to do anything and resume listening.
				if (execution === null) return

				// * Pass the need for Execution to the Executors.
				this.stream.emit('Execution', execution)
			})
		})

		// ! Sends events that are caught by the strategies.
		// * Will emit:
		//   | 'Collection', ['NewBlock', { ... }]
		//   | 'Collection', ['OpenseaOrder', { ... }]
		const collectorsPromises = this.collectors.map(
			async collector => await collector.getCollectionStream(this.stream)
		)

		await Promise.all([
			...collectorsPromises,
			...executorsPromise,
			...strategiesPromises
		])
	}
}
