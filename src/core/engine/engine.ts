import { defineConfig } from './config'
import { EventEmitter } from 'node:events'

import { BlockCollector } from '@/core/collectors/block'
import { LogExecutor } from '@/core/executors/log'
import { Strategy } from '@/core/strategy'

type Collectors = BlockCollector
type Actions = LogExecutor

export class Engine {
	constructor(
		public readonly config: ReturnType<typeof defineConfig>,
		public readonly strategies: Record<
			string,
			Strategy<Collectors, Actions>
		> = {},
		public readonly collectors: Array<Collectors> = [],
		public readonly executors: Array<Actions> = [],
		public readonly stream: EventEmitter = new EventEmitter()
	) {
		// ! TODO: Load the collectors and executors needed for the
		//   strategy that is running.
	}

	run = async () => {
		// ! Catch actions that are generated by collected events.
		// ! This is run first so that we always have Executors
		//   listening for actions when the collectors start.
		const executorsPromise = this.executors.map(async executor =>
			this.stream.on('Execution', async action => {
				await executor.execute(action)
			})
		)

		const strategiesPromises = Object.entries(this.strategies).map(
			async ([name, strategy]) => {
				// ! Initialize the backfilled state.
				if (strategy.syncState) await strategy.syncState()

				// ! Catch and process events as they arrive from the collectors.
				// * Will emit:
				//   | 'Execution', ['Log', { ... }]
				//   | 'Execution', ['SubmitTransaction', { ... }]
				// ? We use `Collection` as the key because this map is only creating
				//   a hook per strategy rather than hook per connector per strategy.
				//   That is not needed for Executors though because we assume them to
				//   be optimistic which means if we are sending an Execution, it is
				//   always meant to be run with the body that is provided, thus,
				//   we can listen for the key of the Execution rather than `Execution`.
				this.stream.on(
					'Collection',
					async ({
						key,
						collection
					}: {
						key: Collectors['key']
						collection: Parameters<Collectors['emit']>[1]
					}) => {
						// * A strategy will always consume the collection however
						//   that does not mean it will always be used. If there
						//   is an action that needs to be taken, then we plan
						//   on passing that to the configured Executors and if there
						//   is no action to take we will go back to waiting for
						//   future messages to arrive.
						const execution = await strategy.processCollection(
							key,
							collection
						)

						// * If the strategy doesn't emit an action then
						//   we don't need to do anything and resume listening.
						if (execution === undefined) return

						// * Pass the need for Execution to the Executors.
						this.stream.emit('Execution', execution)
					}
				)
			}
		)

		// ! Sends events that are caught by the strategies.
		// * Will emit:
		//   | 'Collection', ['NewBlock', { ... }]
		//   | 'Collection', ['OpenseaOrder', { ... }]
		const collectorsPromises = this.collectors.map(
			async collector => await collector.getCollectionStream(this.stream)
		)

		await Promise.all([
			...collectorsPromises,
			...executorsPromise,
			...strategiesPromises
		])
	}
}
