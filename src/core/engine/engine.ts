import { defineConfig } from './config'
import { EventEmitter } from 'node:events'

import { BlockCollector } from '@/core/collectors/block'
import { OpenseaListingCollector } from '@/core/collectors/opensea.listing'
import { LogExecutor } from '@/core/executors/log'
import { Strategy } from '@/core/strategy'

type Collectors = BlockCollector | OpenseaListingCollector
type Actions = LogExecutor

export class Engine {
	constructor(
		public readonly config: ReturnType<typeof defineConfig>,
		public readonly strategies: Record<
			string,
			Strategy<Collectors, Actions>
		> = {},
		public readonly collectors: Array<Collectors> = [],
		public readonly executors: Array<Actions> = [],
		public readonly stream: EventEmitter = new EventEmitter()
	) {
		// ! TODO: Load the collectors and executors needed for the
		//   strategy that is running.
	}

	run = async () => {
		// ! Catch actions that are generated by collected events.
		// ! This is run first so that we always have Executors
		//   listening for actions when the collectors start.
		const executorsPromise = this.executors.map(async executor =>
			this.stream.on('Execution', async action => {
				await executor.execute(action)
			})
		)

		const strategiesPromises = Object.entries(this.strategies).map(
			async ([name, strategy]) => {
				// ! Initialize the backfilled state.
				if (strategy.syncState) await strategy.syncState()

				// ! Catch and process events as they arrive from the collectors.
				// * Will emit:
				//   | 'Execution', ['Log', { ... }]
				//   | 'Execution', ['SubmitTransaction', { ... }]
				this.stream.on('Collection', async event => {
					// * A strategy will always consume the collection however
					//   that does not mean it will always be used. If there
					//   is an action that needs to be taken, then we plan
					//   on passing that to the configured Executors and if there
					//   is no action to take we will go back to waiting for
					//   future messages to arrive.
					const execution = await strategy.processCollection(event)

					// * If the strategy doesn't emit an action then
					//   we don't need to do anything and resume listening.
					if (execution === null) return

					// * Pass the need for Execution to the Executors.
					this.stream.emit('Execution', execution)
				})
			}
		)

		// ! Sends events that are caught by the strategies.
		// * Will emit:
		//   | 'Collection', ['NewBlock', { ... }]
		//   | 'Collection', ['OpenseaOrder', { ... }]
		const collectorsPromises = this.collectors.map(
			async collector => await collector.getCollectionStream(this.stream)
		)

		await Promise.all([
			...collectorsPromises,
			...executorsPromise,
			...strategiesPromises
		])
	}
}
