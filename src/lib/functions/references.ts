import { useEtherscan } from '../hooks/useEtherscan'
import { default as fse } from 'fs-extra'

import { defineConfig } from '@/core/engine/config'
import { logger } from '@/lib/logger'

const generateStaticReferences = ({
	key,
	name,
	abi
}: {
	key: string
	name: string
	abi: string
}) => {
	const protocolGeneration = `
    // Autogenerated file for @${key}. Do not edit.
    export const ${name.replace(' ', '_').toUpperCase()}_NAME = '${name}'
    export const ${name.replace(' ', '_').toUpperCase()}_ABI = ${abi}`

	if (!fse.existsSync(`./src/references/${key}`))
		fse.mkdirSync(`./src/references/${key}`, {
			recursive: true
		})

	fse.writeFileSync(`./src/references/${key}/index.ts`, protocolGeneration)

	logger.info(`Generated ./src/references/${key}/index.ts`)
}

const generateDynamicReferences = ({
	name,
	source
}: {
	name: string
	source: string
}) => {
	// * Remove the double curly braces from the source code.
	// ! I am not sure why this is happening, but it is solved now.
	source = source.replace('{{', '{')
	source = source.replace('}}', '}')

	const contractSources = JSON.parse(source).sources as {
		[key: string]: { content: string }
	}

	Object.entries(contractSources).forEach(([sourceKey, value]) => {
		const directory = `./src/references/${name}/${sourceKey
			.replace('./', '')
			.split('/')
			.slice(0, -1)
			.join('/')}`

		const filename = sourceKey.replace('./', '').split('/').slice(-1)[0]

		fse.mkdirSync(directory, {
			recursive: true
		})

		fse.writeFileSync(`${directory}/${filename}`, value.content)

		logger.info(`Generated ${directory}/${filename}`)
	})
}

export const generateReferences = async <
	T extends ReturnType<typeof defineConfig>['references']
>(
	references: T
) => {
	if (references === undefined) {
		logger.warn('No references defined.')
		return
	}

	const responses = await Promise.all(
		Object.entries(references.contracts).map(async ([key, value]) => {
			const { abi, name, source } = await useEtherscan(
				references.etherscan,
				value
			)

			return { key, name, abi, source }
		})
	)

	// ! Generate the static references.
	responses.forEach(({ key, name, abi }) => {
		generateStaticReferences({ key, name, abi })
	})

	// ! Generate the dynamic references.
	responses.forEach(({ name, source }) => {
		generateDynamicReferences({ name, source })
	})

	logger.success(
		`References generated for ${
			Object.keys(references.contracts).length
		} contracts.`
	)

	process.exit()
}
