import { EventEmitter } from 'stream'

import { Engine, Strategy } from '../lib/types'
import { Collector } from '../lib/types/collectors'
import { NewBlockCollector } from '../collectors/block'
import { OpenseaOrderCollector } from '../collectors/opensea.order'
import { Executor, SubmitTransaction } from '../lib/types/executors'

type Collectors = NewBlockCollector | OpenseaOrderCollector
type Actions = SubmitTransaction

export const useEngine: Engine<Collectors, Actions> = () => {
    const collectors: ReturnType<Collector<Collectors>>[] = []
    const executors: ReturnType<Executor<Actions>>[] = []
    const strategies: ReturnType<Strategy<Collectors, Actions>>[] = []

    const publisher = new EventEmitter()

    const run = async () => {
        // ! Catch actions that are generated by collected events.
        // ! This is run first so that we always have Executors
        //   listening for actions when the collectors start.
        const executorsPromise = executors.map(async (executor) => 
            publisher.on('Execution', async (action) => {
                await executor.execute(action)
            }))

        // Start strategies and enable the event stream.
        const strategiesPromises = strategies.map(async (strategy) => {
            // ! Initialize the backfilled state.
            if (strategy.syncState) await strategy.syncState()

            // * Process events as they arrive from the collectors.
            publisher.on('Collection', async (event) => {
                const execution = await strategy.processEvent(event)

                // * If the strategy doesn't emit an action then 
                //   we don't need to do anything.
                if (execution === null) return

                publisher.emit('Execution', execution)
            })
        })

        // ! Sends events that are caught by the strategies.
        // * Will emit:
        //   | 'Collection', ['NewBlock', { ... }]
        //   | 'Collection', ['OpenseaOrder', { ... }]
        const collectorsPromises = collectors.map(async (collector) => 
            await collector.getEventStream(publisher))

        await Promise.all([
            ...collectorsPromises,
            ...executorsPromise,
            ...strategiesPromises,
        ])
    }

    return {
        collectors,
        executors,
        strategies,
        run,
    }
}
