import { EventEmitter } from 'stream'

import { Engine, Strategy } from '../lib/types'

// * Collectors
import { Collector } from '../lib/types/collectors'
import { NewBlockCollector } from '../collectors/block'
import { OpenseaOrderCollector } from '../collectors/opensea.order'

// * Executors
import { Executor } from '../lib/types/executors'
import { MempoolTransaction } from '../executors/mempool'

type Collectors = NewBlockCollector | OpenseaOrderCollector
type Actions = MempoolTransaction

export const useEngine: Engine<Collectors, Actions> = () => {
    const collectors: ReturnType<Collector<Collectors>>[] = []
    const executors: ReturnType<Executor<Actions>>[] = []
    const strategies: ReturnType<Strategy<Collectors, Actions>>[] = []

    const stream = new EventEmitter()

    const run = async () => {
        // ! Catch actions that are generated by collected events.
        // ! This is run first so that we always have Executors
        //   listening for actions when the collectors start.
        const executorsPromise = executors.map(async (executor) => 
            stream.on('Execution', async (action) => {
                await executor.execute(action)
            }))

        const strategiesPromises = strategies.map(async (strategy) => {
            // ! Initialize the backfilled state.
            if (strategy.syncState) await strategy.syncState()

            // ! Catch and process events as they arrive from the collectors.
            // * Will emit:
            //   | 'Execution', ['Log', { ... }]
            //   | 'Execution', ['SubmitTransaction', { ... }]
            stream.on('Collection', async (event) => {
                // * A strategy will always consume the collection however
                //   that does not mean it will always be used. If there
                //   is an action that needs to be taken, then we plan
                //   on passing that to the configured Executors and if there
                //   is no action to take we will go back to waiting for
                //   future messages to arrive.
                const execution = await strategy.processEvent(event)

                // * If the strategy doesn't emit an action then 
                //   we don't need to do anything and resume listening.
                if (execution === null) return

                // * Pass the need for Execution to the Executors.
                stream.emit('Execution', execution)
            })
        })

        // ! Sends events that are caught by the strategies.
        // * Will emit:
        //   | 'Collection', ['NewBlock', { ... }]
        //   | 'Collection', ['OpenseaOrder', { ... }]
        const collectorsPromises = collectors.map(async (collector) => 
            await collector.getEventStream(stream))

        await Promise.all([
            ...collectorsPromises,
            ...executorsPromise,
            ...strategiesPromises,
        ])
    }

    return {
        collectors,
        executors,
        strategies,
        run,
    }
}
