import { useEtherscan } from '../hooks/useEtherscan'
import { default as fse } from 'fs-extra'

import { defineConfig } from '@/core/engine/config'
import { DEFAULT_ETHERSCAN } from '@/core/engine/constants'
import { getArtifacts } from '@/lib/functions/artifacts'
import { logger } from '@/lib/logger'

const generateStaticReferences = ({
	key,
	name,
	abi,
	bytecode,
	deployedBytecode
}: {
	key: string
	name: string
	abi: string
	bytecode?: string
	deployedBytecode?: string
}) => {
	let protocolGeneration = `
    // Autogenerated file for @${key}. Do not edit.
    export const ${name
		.replace(' ', '_')
		.toUpperCase()}_NAME = '${name} as const'
    export const ${name.replace(' ', '_').toUpperCase()}_ABI = ${abi} as const`

	if (bytecode)
		protocolGeneration += `
    export const ${name
		.replace(' ', '_')
		.toUpperCase()}_BYTECODE = '${bytecode}' as const`

	if (deployedBytecode)
		protocolGeneration += `
    export const ${name
		.replace(' ', '_')
		.toUpperCase()}_DEPLOYED_BYTECODE = '${deployedBytecode}' as const`

	if (!fse.existsSync(`./src/references/${key}`))
		fse.mkdirSync(`./src/references/${key}`, {
			recursive: true
		})

	fse.writeFileSync(`./src/references/${key}/index.ts`, protocolGeneration)

	logger.info(`Generated ./src/references/${key}/index.ts`)
}

const generateDynamicReferences = ({
	name,
	source
}: {
	name: string
	source: string | undefined
}) => {
	if (!source) return

	// * Remove the double curly braces from the source code.
	// ! I am not sure why this is happening, but it is solved now.
	source = source.replace('{{', '{')
	source = source.replace('}}', '}')

	const contractSources = JSON.parse(source).sources as {
		[key: string]: { content: string }
	}

	Object.entries(contractSources).forEach(([sourceKey, value]) => {
		const directory = `./src/references/${name}/${sourceKey
			.replace('./', '')
			.split('/')
			.slice(0, -1)
			.join('/')}`

		const filename = sourceKey.replace('./', '').split('/').slice(-1)[0]

		fse.mkdirSync(directory, {
			recursive: true
		})

		fse.writeFileSync(`${directory}/${filename}`, value.content)

		logger.info(`Generated ${directory}/${filename}`)
	})
}

export const generateReferences = async <
	T extends ReturnType<typeof defineConfig>['references']
>(
	references: T
) => {
	if (references === undefined) {
		logger.warn('No references defined.')
		return
	}

	// ! Generate the deployed contract references.
	// if(references.contracts)
	let responses: Array<{
		key: string
		name: string
		address?: string
		abi: string
		bytecode?: string
		deployedBytecode?: string
		source?: string
	}> = []

	// ! Generate the base responses for every 'deployed' contract being retrieved.
	responses = responses.concat(
		await Promise.all(
			Object.entries(references.contracts || []).map(
				async ([key, address]) => {
					const { abi, name, source } = await useEtherscan(
						references.etherscan || DEFAULT_ETHERSCAN,
						address
					)

					return { key, address, name: key, abi, source }
				}
			)
		)
	)

	// ! Generate the base respones for local artifacts (ideally generated by Hardhat).
	// * Get all the files in the artifacts directory.
	responses = responses.concat(await getArtifacts(references))

	await Promise.all(
		responses.map(
			async ({ key, name, address, abi, bytecode, deployedBytecode }) => {
				// ! If the bytecode was not provided, but we can retrieve it, then do so.
				// * This is not the creationCode (deployedBytecode) but the actual bytecode.
				if (references.bytecode && address && bytecode === undefined)
					bytecode = await references.bytecode(address, 'latest')

				generateStaticReferences({
					key,
					name,
					abi,
					bytecode,
					deployedBytecode
				})
			}
		)
	)

	// ! Generate the dynamic references.
	// * If `.source` is undefined, then it is a local artifact and the Solidity
	//   file was already created by the user.
	responses.forEach(({ name, source }) => {
		generateDynamicReferences({ name, source })
	})

	logger.success(`References generated for ${responses.length} contracts.`)
}
